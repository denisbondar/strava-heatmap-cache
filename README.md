# STRAVA Heatmap cache

Скрипт предназначен для кэширования тайлов тепловой карты Strava с целью использования
их в приложении OsmAnd в качестве оффлайн карты или в приложении JOSM также в качестве
слоя, помогающего при картографировании.

Скрипт работает в двух режимах: режим загрузки тайлов в кэш и режим выдачи тайлов из кэша по протоколу HTTP.

## Запуск в Docker контейнере

Следующие команды содержат параметр `--volume` указывающий на каталог на диске,
в которой будет смонтирован каталог с кэшем контейнера. Перед тем, как продолжить,
этот каталог необходимо создать:
```bash
mkdir -p /var/strava-cache
```

### Запуск построителя кэша

Функция построения (прогрева) кэша проверяет наличие тайлов в кэше в заданной
области географических координат и в заданном диапазоне масштабов. Если тайл
отсутствует — он загружается с CDN-серверов Strava и сохраняется в кэше.

Для запуска построителя кэша достаточно выполнить команду `build`
в Docker-контейнере следующим образом:

```bash
docker run --rm \
  --volume /var/strava-cache:/app/cache \
  --env KEY_PAIR_ID=CloudFront-Key-Pair-Id_from_cookies \
  --env SIGNATURE=CloudFront-Signature_from_cookies \
  --env POLICY=CloudFront-Policy_from_cookies \
  --name strava-heatmap-cache \
  denisbondar/strava-heatmap-cache \
  build
```

После того как построитель кэша отработает — работа контейнера будет завершена.

**Стоит учитывать**, что одна итерация построителя кэша ограничена 6000 тайлами.
Это связано с лимитом на CDN CloudFront. Прежде чем запускать построитель для
следующей партии тайлов, следует подождать несколько минут, иначе CDN может
заблокировать доступ для вашей учетной записи на какое-то время. 

#### Значения переменных в приведенных примерах

В качестве значений для переменных окружения `KEY_PAIR_ID`, `SIGNATURE`, `POLICY`
необходимо указать соответствующие значения, полученные из cookie на сайте
https://www.strava.com/heatmap. Для этого аутентифицируйтесь на сайте, затем
найдите в cookie домена strava.com переменные
`CloudFront-Key-Pair-Id`, `CloudFront-Policy`, `CloudFront-Signature`

Открыть окно с Cookie в Chrome последних версий можно перейдя в "Инструменты разработчика",
затем на вкладку "Приложение" и там в разделе "Память" открыть Файлы Cookie.
Затем в окне по центру, где появится список cookies, в поле фильтра написать **CloudFront**.

Если у вас нет учётной записи на strava.com, то вы сможете загрузить только тайлы
масштаба не более 11.

### Запуск HTTP-сервера

Для запуска web-модуля, принимающего http-запросы вида `http://127.0.0.1:8080/z/x/y.png`, запустите
контейнер *без указания команды* следующим образом:

```bash
docker run --rm \
  --volume /var/strava-cache:/app/cache \
  --publish 127.0.0.1:8080:8080 \
  --env KEY_PAIR_ID=CloudFront-Key-Pair-Id_from_cookies \
  --env SIGNATURE=CloudFront-Signature_from_cookies \
  --env POLICY=CloudFront-Policy_from_cookies \
  --name strava-heatmap-cache \
  denisbondar/strava-heatmap-cache
```

Контейнер с web-модулем будет работать постоянно. В конфигурации выше указан порт 8080,
на котором принимаются http-подключения. Вы можете изменить его на более подходящий
для вас, например, `--publish 127.0.0.1:80:8080` будет принимать подключение на 80 порту.

Если Вам зачем-то понадобилось открыть доступ к своему тайловому кэшу в интернет,
то вам желательно использовать nginx в качестве фронтенда к web-модулю.

#### Добавление в конфигурацию стека GNINX сервера

В этом нет необходимости, если вы собираетесь работать с кэшем локально, не через интернет.

Варианты использования кэша, приведенные ниже, рассчитаны на использование web-модуля,
работающего на порту 8080 (без NGINX).

Пример конфигурации nginx в качестве реверсивного прокси (файл /etc/nginx/conf.d/strava.conf):
```
server {
    listen 80;
    server_name <доменное_имя_вашего_сервера>;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_redirect default;
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

## Использование кэша в различных приложениях

### Использование в качествео оффлайн карты OsmAnd

1. Создайте онлайн карту в OsmAnd. Назовите ее, например, **Strava Heatmap**.
Укажите диапазон масштаба 8..16. Можно указать URL бесплатных тайлов — он
будет использоваться, если OsmAnd не найдет тайлов в кэше.
`https://heatmap-external-a.strava.com/tiles/ride/bluered/{0}/{1}/{2}.png`. 
[Подробнее на сайте OsmAnd](https://osmand.net/features/online-maps-plugin).

2. Скопируйте каталог с кэшем на Ваше андроид-устройство в каталог
`/Android/data/net.osmand/files/tiles/Strava Heatmap` или одноименный каталог,
если вы перенесли каталог в другое место (например, на SD-карту).
Так как файлов может быть очень много, то лучше создайте архив на компьютере,
скопируйте его на смартфон и там разархивируйте. Самый простой способ — переименовать
каталог cache в Strava Heatmap и заархивировать его, затем переименовать обратно в cache.
Структура каталогов в результате должна быть примерно такой:
`...net.osmand/files/tiles/Strava Heatmap/7/74/`

3. Откройте приложение OsmAnd. Меню - Настройки карты - Карта наложения.
Выберите **Strava Heatmap** и укажите степень прозрачности. Или же включите опцию
*Показывать регулировку прозрачности*, чтобы управлять ею прямо с карты.

### Использование в качестве оффлайн слоя в JOSM

1. В JOSM в меню Слои - Настройки слоёв... в нижней части окна в списке
"Выбранные" нажмите кнопку **+TMS** и введите в п.4 готовый URL следующего вида:
`tms[16]:file:///var/strava-cache/{zoom}/{x}/{y}png.tile`. Путь к кэшу указан
такой же, как и для volume в примере запуска с использованием Docker, но у вас он
может быть другим. В п.5 введите название слоя, например, `Strava Heatmap`.
Нажмите **ОК** в окне добавления подложки и **ОК** в окне настроек.

2. В меню Слои выберите слой **Strava Heatmap** — новый слой будет добавлен и
тайлы будут отображены на карте.

3. Рекомендуется немного размыть слой, т.к. границы тепловой карты могут быть
слишком резкими. Нажмите в списке слоев на слой **Strava Heatmap**, затем внизу
нажмите кнопку **Изменить видимость выбранного слоя** и настройте максимально
комфортную резкость и другие параметры отображения по необходимости.

### Использования в качестве overlay в BRouter

[BRouter](http://brouter.de/) - довольно интересный проект для веломаршрутизации,
позволяющий тонко настраивать параметры и пожелания велосипедиста, которые
учитываются при построении маршрутов. Информация о дорогах, их покрытии и
качестве берется из OSM, так что актуализируя информацию о дорогах в своем
регионе OSM вы косвенно улучшается и работу маршрутизатора.

Еще одной интересной особенностью данного проекта является возможность добавления
своих собственных Слоёв (Layers) и Наложений (Overlays).

Для использования этой возможности, вам необходимо запустить wsgi-модуль.

1. Перейдите в [BRouter-Web](http://brouter.de/brouter-web/)

2. Справа на панели в списке слоёв (Layers) нажмите кнопку Custom layers.

3. В поле Custom layer name укажите, например, Strava Heatmap, а в поле
Custom layer URL укажите `http://127.0.0.1:8080/{z}/{x}/{y}.png`, если вы используете
настройки, указанные по умолчанию в этой инструкции. Иначе номер порта или адрес
могут быть другими.

4. Нажмите **Add overlay**.

В списке слоёв появится ваш новый слой наложения. Включите его при помощи чекбокса.
Вы также можете управлять прозрачностью этого слоя.
Существует проблема. Если масштаб карты более чем 16, то слой исчезает, т.к.
нет тайлов более крупного масштаба. Это особенность BRouter.

## Известные проблемы и дорожная карта

На данный момент скрипт находится в стадии разработки, поэтому многие моменты в нем
могут показаться неочевидными или непонятными. Например:

1. На данный момент в скрипт жестко зашиты координаты Одесского региона.
Позже это будет вынесено в переменные окружения и в параметры командной строки,
если скрипт запускается не через Docker.

2. Остальные жестко зашитые параметры также будут вынесены.

3. Проблема с ограничением загрузки со стороны CloudFront. Сейчас она частично
решается при помощи семафора для асинхронного запуска и частично как ограничение
количества загружаемых тайлов за один раз. Но это всё равно не позволяет одним
запуском загрузить все тайлы во всех масштабах.

4. Планируется реализовать http-endpoint для загрузки тайлов по http из кэша
с возможностью наполнения кэша, если запрашиваемых тайлов в нем нет.

5. Планируется при прогреве кэша реализовать возможность перезагрузки тайлов,
если в кэше тайл устарел (старше ?? дней?)